체스
<br>>>>
 - 이름 : 체스
<br> - 작성 : Python
<br> - 제작 기간 : 2주
<br> - 제작 시기 : 9월
<br> - 설명 : 파이썬을 이용하여 만든 체스 프로그램이다. 여타 모듈 없이 기본 콘솔을 이용하여 조작가능하며 룰은 기존의 체스와 동일하다.
<br>>>>
from myDef import *
<br>
<br>#add En passant
<br>#add Checkmate check
<br>#menu to see record
<br>#turn color to 0, 1
<br>
<br>class game:
<br>&emsp;def __init__(self):
<br>&emsp;&emsp;temp = []
<br>&emsp;&emsp;self.board = [] #[x, abcd...][y, 1234...]
<br>&emsp;&emsp;for i in range(10):&emsp; #[0] simbol [1] pieces color [2] pieces class
<br>&emsp;&emsp;&emsp;for j in range(10): #[3] serial number [4] movable squares
<br>&emsp;&emsp;&emsp;&emsp;temp.append([' ']) #class 1. King 2. Queen 3. Rook 4. Bishop 5. knight 6. Pawn
<br>&emsp;&emsp;&emsp;self.board.append(temp)
<br>&emsp;&emsp;&emsp;temp = []
<br>&emsp;&emsp;self.sub_board = [['  ']*10 for _ in range (10)] #sub output
<br>&emsp;&emsp;self.turn_color = 1
<br>&emsp;&emsp;self.death_pieces = [[], []]
<br>&emsp;&emsp;self.movable_squares = [[], []]
<br>&emsp;&emsp;self.record = []
<br>&emsp;&emsp;self.record_player = []
<br>&emsp;&emsp;self.main_cursor_point = []
<br>&emsp;&emsp;self.sub_cursor_point = []
<br>&emsp;&emsp;self.king_position = [[5, 8], [5, 1]] #white, black
<br>&emsp;&emsp;self.temp = []
<br>&emsp;&emsp;self.castling = [1, 1, 1, 1]
<br>&emsp;&emsp;self.simbols = [['♚ ', '♔ '], ['♛ ', '♕ '], ['♜ ', '♖ '], ['♝ ', '♗ '], ['♞ ', '♘ '], ['♟', '♙ ']]
<br>&emsp;&emsp;self.squares = ['■', '□']
<br>&emsp;&emsp;self.cursor = ['▼', '▽']
<br>&emsp;&emsp;setting = [3, 5, 4, 2, 1, 4, 5, 3, 3, 7, 5, 2, 1, 6, 8, 4]
<br>&emsp;&emsp;
<br>&emsp;&emsp;for i in range(1, 9): #board setting
<br>&emsp;&emsp;&emsp;self.board[i][8] = [self.simbols[setting[i - 1] - 1][0], 1, setting[i - 1], setting[i + 7], []] #minor pieces
<br>&emsp;&emsp;&emsp;self.board[i][1] = [self.simbols[setting[i - 1] - 1][1], 2, setting[i - 1], setting[i + 7], []]
<br>&emsp;&emsp;&emsp;self.board[i][7] = [self.simbols[5][0], 1, 6, i + 8, []] #pawn
<br>&emsp;&emsp;&emsp;self.board[i][2] = [self.simbols[5][1], 2, 6, i + 8, []]
<br>&emsp;&emsp;&emsp;for j in [0, 9]: 
<br>&emsp;&emsp;&emsp;&emsp;self.board[i][j] = [chr(96 + i) + ' ']
<br>&emsp;&emsp;&emsp;&emsp;self.board[j][i] = [9 - i]
<br>&emsp;&emsp;&emsp;&emsp;self.sub_board[j][i] = ' '
<br>
<br>&emsp;&emsp;&emsp;for j in range(1, 9): #board square setting
<br>&emsp;&emsp;&emsp;&emsp;if self.board[i][j][0] == ' ':
<br>&emsp;&emsp;&emsp;&emsp;&emsp;if (i % 2 != 0 and j % 2 != 0) or (i % 2 == 0 and j % 2 == 0):
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;self.board[i][j] = [self.squares[0], 0]
<br>&emsp;&emsp;&emsp;&emsp;&emsp;else:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;self.board[i][j] = [self.squares[1], 0]
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
<br>&emsp;&emsp;del setting
<br>&emsp;&emsp;del temp
<br>&emsp;&emsp;
<br>&emsp;def running(self):
<br>&emsp;&emsp;while True:
<br>&emsp;&emsp;&emsp;self.movable()
<br>&emsp;&emsp;&emsp;while True:
<br>&emsp;&emsp;&emsp;&emsp;temp = self.turn()
<br>&emsp;&emsp;&emsp;&emsp;if type(temp) != type(None):
<br>&emsp;&emsp;&emsp;&emsp;&emsp;break
<br>&emsp;&emsp;&emsp;self.turn_color = 1 if self.turn_color == 2 else 2
<br>&emsp;&emsp;&emsp;self.record.append([temp[0], temp[1]])
<br>&emsp;&emsp;&emsp;self.record_player.append([un_position(temp[0]), un_position(temp[1])])
<br>&emsp;&emsp;&emsp;check = self.check()
<br>&emsp;&emsp;&emsp;if type(check) == type(int()):
<br>&emsp;&emsp;&emsp;&emsp;return check, self.record_player
<br>&emsp;&emsp;&emsp;temp = ''
<br>
<br>&emsp;def turn(self):
<br>&emsp;&emsp;col = 'White' if self.turn_color == 1 else 'Black'
<br>&emsp;&emsp;while True:
<br>&emsp;&emsp;&emsp;if self.main_cursor_point != []:
<br>&emsp;&emsp;&emsp;&emsp;self.clean_mark()
<br>&emsp;&emsp;&emsp;self.draw()
<br>&emsp;&emsp;&emsp;print('{}. {} turn.'.format(len(self.record) + 1, col))
<br>&emsp;&emsp;&emsp;pos, sel = self.select()
<br>&emsp;&emsp;&emsp;self.draw()
<br>&emsp;&emsp;&emsp;piece_class = change_NtoP(self.board[pos[0]][pos[1]][2])
<br>&emsp;&emsp;&emsp;print("{} {} selected.".format(sel, piece_class))
<br>&emsp;&emsp;&emsp;pos2, nex_mov = self.choose(pos)
<br>&emsp;&emsp;&emsp;if type(pos2) == type(0):
<br>&emsp;&emsp;&emsp;&emsp;continue
<br>&emsp;&emsp;
<br>&emsp;&emsp;&emsp;while True: #last check part
<br>&emsp;&emsp;&emsp;&emsp;self.draw()
<br>&emsp;&emsp;&emsp;&emsp;last_check = input("{} {} move to {}?\n(y/n) : ".format(sel, piece_class, nex_mov))
<br>&emsp;&emsp;&emsp;&emsp;if last_check == 'y' or last_check == 'Y':
<br>&emsp;&emsp;&emsp;&emsp;&emsp;self.move(pos, pos2)
<br>&emsp;&emsp;&emsp;&emsp;&emsp;return pos, pos2
<br>&emsp;&emsp;&emsp;&emsp;elif last_check == 'n' or last_check == 'N':
<br>&emsp;&emsp;&emsp;&emsp;&emsp;last_check = ''
<br>&emsp;&emsp;&emsp;&emsp;&emsp;break
<br>&emsp;&emsp;&emsp;&emsp;else:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;print("Error : Please input y or n")
<br>
<br>
<br>########################################
<br>############## check part ##############
<br>&emsp;def check(self):
<br>&emsp;&emsp;for i in self.king_position:
<br>&emsp;&emsp;&emsp;if self.board[i[0]][i[1]][2] != 1:
<br>&emsp;&emsp;&emsp;&emsp;return self.board[i[0]][i[1]][1]
<br>&emsp;&emsp;
<br>&emsp;&emsp;&emsp;&emsp;&emsp;
<br>#######################################
<br>############## draw part ##############
<br>&emsp;def draw(self):
<br>&emsp;&emsp;print('\n')
<br>&emsp;&emsp;for i in range(len(self.board)):
<br>&emsp;&emsp;&emsp;for j in range(len(self.sub_board[i])):
<br>&emsp;&emsp;&emsp;&emsp;print(self.sub_board[j][i], end=' ')
<br>&emsp;&emsp;&emsp;print('')
<br>&emsp;&emsp;&emsp;for j in range(len(self.board[i])):
<br>&emsp;&emsp;&emsp;&emsp;print(self.board[j][i][0], end=' ')
<br>&emsp;&emsp;&emsp;print('')
<br>&emsp;&emsp;print('')
<br>
<br>
<br>#########################################
<br>############## select part ##############
<br>&emsp;def select(self):
<br>&emsp;&emsp;while True:
<br>&emsp;&emsp;&emsp;sel = input("Select : ")
<br>&emsp;&emsp;&emsp;if len(sel) == 2:
<br>&emsp;&emsp;&emsp;&emsp;pos = position(sel)
<br>&emsp;&emsp;&emsp;&emsp;if pos != None:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;if isin([pos[0], pos[1]], 0, 9):
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;print("Input Error : Please input in a - h, 1 - 8")
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;continue
<br>&emsp;&emsp;&emsp;&emsp;&emsp;elif self.board[pos[0]][pos[1]][1] != self.turn_color:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;print("Error : Please select own piece")
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;continue
<br>&emsp;&emsp;&emsp;&emsp;&emsp;elif len(self.board[pos[0]][pos[1]][4]) == 0:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;print("Error : This piece can't move!")
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;continue
<br>&emsp;&emsp;&emsp;&emsp;&emsp;else:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;self.set_curser(pos)
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return pos, sel
<br>&emsp;&emsp;&emsp;&emsp;else:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;print("Input Error : Please input in a - h, 1 - 8")
<br>&emsp;&emsp;&emsp;else:
<br>&emsp;&emsp;&emsp;&emsp;print("Input Error : Please input in a - h, 1 - 8")
<br>
<br>&emsp;def choose(self, pos):
<br>&emsp;&emsp;while True: #choose move square part
<br>&emsp;&emsp;&emsp;nex_mov = input("Move(no input to cancle select) : ")
<br>&emsp;&emsp;&emsp;if nex_mov == '':
<br>&emsp;&emsp;&emsp;&emsp;print("Cancle select")
<br>&emsp;&emsp;&emsp;&emsp;return 0, 0
<br>&emsp;&emsp;&emsp;elif len(nex_mov) == 2:
<br>&emsp;&emsp;&emsp;&emsp;pos2 = position(nex_mov)
<br>&emsp;&emsp;&emsp;&emsp;if pos2 != None:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;if pos2 in self.board[pos[0]][pos[1]][4]:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return pos2, nex_mov
<br>&emsp;&emsp;&emsp;&emsp;&emsp;else:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;print("Error : There is not movable square.")
<br>&emsp;&emsp;&emsp;&emsp;else:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;print("Input Error : Please input in a - h, 1 - 8")
<br>&emsp;&emsp;&emsp;else:
<br>&emsp;&emsp;&emsp;&emsp;print("Error : There is not movable square.")
<br>&emsp;&emsp;&emsp;&emsp;
<br>&emsp;def promotion(self):
<br>&emsp;&emsp;print("Choose class of piece to upgrade your Pawn!")
<br>&emsp;&emsp;while True:
<br>&emsp;&emsp;&emsp;select = input("\n1. Queen\n2. Rook\n3. Bishop\n4. Knight\nChoose : ")
<br>&emsp;&emsp;&emsp;if select in ['1', '2', '3', '4']:
<br>&emsp;&emsp;&emsp;&emsp;return int(select)
<br>&emsp;&emsp;&emsp;print("Wrong input. Please input again.")
<br>&emsp;&emsp;&emsp;
<br>#######################################################
<br>############## Calculate movable squares ##############
<br>&emsp;def movable(self):
<br>&emsp;&emsp;temp = []
<br>&emsp;&emsp;temp2 = []
<br>&emsp;&emsp;for i in range(1, 9):
<br>&emsp;&emsp;&emsp;for j in range(1, 9):
<br>&emsp;&emsp;&emsp;&emsp;if self.board[i][j][0] not in self.squares: #Is it piece?
<br>&emsp;&emsp;&emsp;&emsp;&emsp;if self.board[i][j][2] in [2, 3, 4]:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;temp = self.move_cal_straight([i, j], self.board[i][j][2])
<br>&emsp;&emsp;&emsp;&emsp;&emsp;else:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;temp = self.move_cal_other([i, j], self.board[i][j][2])
<br>&emsp;&emsp;&emsp;&emsp;&emsp;
<br>&emsp;&emsp;&emsp;&emsp;&emsp;self.board[i][j][4] = temp
<br>&emsp;&emsp;&emsp;&emsp;&emsp;temp2.append(temp)
<br>&emsp;&emsp;&emsp;&emsp;&emsp;temp = []
<br>&emsp;&emsp;&emsp;&emsp;&emsp;
<br>&emsp;def move_cal_straight(self, pos, cla):
<br>&emsp;&emsp;temp = []
<br>&emsp;&emsp;xmym = [small_eq(pos[0], pos[1]), 1]
<br>&emsp;&emsp;xpym = [small_eq(9 - pos[0], pos[1]), 2]
<br>&emsp;&emsp;xmyp = [small_eq(pos[0], 9 - pos[1]), 3]
<br>&emsp;&emsp;xpyp = [small_eq(9 - pos[0], 9 - pos[1]), 4]
<br>&emsp;&emsp;xm = [pos[0], 5]
<br>&emsp;&emsp;xp = [9 - pos[0], 6]
<br>&emsp;&emsp;ym = [pos[1], 7]
<br>&emsp;&emsp;yp = [9 - pos[1], 8]
<br>
<br>&emsp;&emsp;len_list = switch(cla, [2, 3, 4], [[xmym, xpym, xmyp, xpyp, xm, xp, ym, yp], [xm, xp, ym, yp], [xmym, xpym, xmyp, xpyp]])
<br>&emsp;&emsp;&emsp;
<br>&emsp;&emsp;for length in len_list:
<br>&emsp;&emsp;&emsp;for i in range(1, length[0]): 
<br>&emsp;&emsp;&emsp;&emsp;j = switch(length[1], [1, 2, 3, 4, 5, 6, 7, 8], [-i, i, -i, i, -i, i, 0, 0])
<br>&emsp;&emsp;&emsp;&emsp;k = switch(length[1], [1, 2, 3, 4, 5, 6, 7, 8], [-i, -i, i, i, 0, 0, -i, i])
<br>&emsp;&emsp;&emsp;&emsp;&emsp;
<br>&emsp;&emsp;&emsp;&emsp;if self.board[pos[0] + j][pos[1] + k][1] == 0:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;temp.append([pos[0] + j, pos[1] + k])
<br>&emsp;&emsp;&emsp;&emsp;elif self.board[pos[0] + j][pos[1] + k][1] == self.board[pos[0]][pos[1]][1]:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;break
<br>&emsp;&emsp;&emsp;&emsp;elif self.board[pos[0] + j][pos[1] + k][1] != self.board[pos[0]][pos[1]][1]:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;temp.append([pos[0] + j, pos[1] + k])
<br>&emsp;&emsp;&emsp;&emsp;&emsp;break
<br>
<br>&emsp;&emsp;if cla == 3: #castling
<br>&emsp;&emsp;&emsp;temp_bool = True
<br>&emsp;&emsp;&emsp;if pos in [[1, 1], [1, 8], [8, 1], [8, 8]]: 
<br>&emsp;&emsp;&emsp;&emsp;temp_num = switch(pos, [[1, 1], [1, 8], [8, 1], [8, 8]], [0, 1, 2, 3])
<br>&emsp;&emsp;&emsp;&emsp;if self.castling[temp_num] == 1:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;if temp_num < 2: #left side Rook
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;t1, t2, t3 = 2, 5, 1 #2, 3, 4
<br>&emsp;&emsp;&emsp;&emsp;&emsp;else: #Right side Rook
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;t1, t2, t3 = 7, 5, -1 #7, 6
<br>&emsp;&emsp;&emsp;&emsp;&emsp;for i in range(t1, t2, t3):
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;if self.board[i][pos[1]][1] != 0:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;temp_bool = False
<br>&emsp;&emsp;&emsp;&emsp;if temp_bool == True:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;num = 0 if temp_num % 2 != 0 else 1
<br>&emsp;&emsp;&emsp;&emsp;&emsp;temp.append(self.king_position[num])
<br>&emsp;&emsp;return temp
<br>
<br>&emsp;def move_cal_other(self, pos, cla):
<br>&emsp;&emsp;temp = []
<br>&emsp;&emsp;if cla == 1: #King
<br>&emsp;&emsp;&emsp;for i in range(-1, 2):
<br>&emsp;&emsp;&emsp;&emsp;for j in range(-1, 2):
<br>&emsp;&emsp;&emsp;&emsp;&emsp;if isin(pos[0] + i, 0, 9) and isin(pos[1] + j, 0, 9) and self.board[pos[0] + i][pos[1] + j][1] != self.turn_color:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;temp.append([pos[0] + i, pos[1] + j])
<br>
<br>&emsp;&emsp;elif cla == 5: #Knight
<br>&emsp;&emsp;&emsp;for i, j in [[-2, -1], [-2, 1], [2, -1], [2, 1], [-1, 2], [1, 2], [-1, -2], [1, -2]]:
<br>&emsp;&emsp;&emsp;&emsp;if isin(pos[0] + i, 0, 9) and isin(pos[1] + j, 0, 9) and self.board[pos[0] + i][pos[1] + j][1] != self.turn_color:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;temp.append([pos[0] + i, pos[1] + j])
<br>
<br>&emsp;&emsp;elif cla == 6: #Pawn
<br>&emsp;&emsp;&emsp;enemy = 1 if self.turn_color == 2 else 2
<br>&emsp;&emsp;&emsp;direction = -1 if self.turn_color == 1 else 1
<br>&emsp;&emsp;&emsp;if (self.turn_color == 1 and pos[1] == 7) or (self.turn_color == 2 and pos[1] == 2): #first move
<br>&emsp;&emsp;&emsp;&emsp;if self.board[pos[0]][pos[1] + direction][1] == 0:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;temp.append([pos[0], pos[1] + direction])
<br>&emsp;&emsp;&emsp;&emsp;&emsp;if self.board[pos[0]][pos[1] + (direction * 2)][1] == 0:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;temp.append([pos[0], pos[1] + (direction * 2)])
<br>
<br>&emsp;&emsp;&emsp;else: #normal move
<br>&emsp;&emsp;&emsp;&emsp;if self.board[pos[0]][pos[1] + direction][1] == 0:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;temp.append([pos[0], pos[1] + direction])
<br>
<br>&emsp;&emsp;&emsp;for i in [-1, 1]: #attack
<br>&emsp;&emsp;&emsp;&emsp;if isin(pos[0] + i, 0, 9):
<br>&emsp;&emsp;&emsp;&emsp;&emsp;if self.board[pos[0] + i][pos[1] + direction][1] == enemy:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;temp.append([pos[0] + i, pos[1] + direction])
<br>
<br>&emsp;&emsp;return temp
<br>
<br>#######################################
<br>############## move part ##############
<br>
<br>&emsp;def move(self, pos1, pos2): # move part, 1 piece, 2 place
<br>&emsp;&emsp;if self.board[pos1[0]][pos1[1]][2] == 1: #king's position change
<br>&emsp;&emsp;&emsp;self.king_position[self.turn_color - 1] = pos2
<br>&emsp;&emsp;&emsp;num = [0, 2] if self.turn_color == 0 else [1, 3] #Can't Castling when after king move
<br>&emsp;&emsp;&emsp;for i in num:
<br>&emsp;&emsp;&emsp;&emsp;if self.castling[i] == 1:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;self.castling[i] = 0
<br>&emsp;&emsp;if self.board[pos1[0]][pos1[1]][2] == 3 and pos1 in [[1, 1], [1, 8], [8, 1], [8, 8]]:
<br>&emsp;&emsp;&emsp;temp_num = switch(pos1, [[1, 1], [1, 8], [8, 1], [8, 8]], [0, 1, 2, 3])
<br>&emsp;&emsp;&emsp;if self.castling[temp_num] == 1: #Castling
<br>&emsp;&emsp;&emsp;&emsp;self.castling[temp_num] = 0
<br>&emsp;&emsp;&emsp;&emsp;if self.board[pos2[0]][pos2[1]][2] == 1 and self.board[pos1[0]][pos1[1]][1] == self.board[pos2[0]][pos2[1]][1]:
<br>&emsp;&emsp;&emsp;&emsp;&emsp;if pos1[0] == 1: #Left side
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;self.board[pos2[0] - 2][pos2[1]] = self.board[pos2[0]][pos2[1]]
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;self.board[pos2[0] - 1][pos2[1]] = self.board[pos1[0]][pos1[1]]
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;self.king_position[self.turn_color - 1] = [pos2[0] - 2, pos2[1]]
<br>&emsp;&emsp;&emsp;&emsp;&emsp;else: #Right side
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;self.board[pos2[0] + 2][pos2[1]] = self.board[pos2[0]][pos2[1]]
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;self.board[pos2[0] + 1][pos2[1]] = self.board[pos1[0]][pos1[1]]
<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;self.king_position[self.turn_color - 1] = [pos2[0] + 2, pos2[1]]
<br>&emsp;&emsp;&emsp;&emsp;&emsp;self.board[pos2[0]][pos2[1]] = [self.squares[0] if (pos1[0] % 2 != 0 and pos1[1] % 2 != 0) or (pos1[0] % 2 == 0 and pos1[1] % 2 == 0) else self.squares[1], 0]
<br>&emsp;&emsp;&emsp;&emsp;&emsp;self.board[pos1[0]][pos1[1]] = [self.squares[0] if (pos1[0] % 2 != 0 and pos1[1] % 2 != 0) or (pos1[0] % 2 == 0 and pos1[1] % 2 == 0) else self.squares[1], 0]
<br>&emsp;&emsp;&emsp;&emsp;&emsp;return
<br>&emsp;&emsp;if self.board[pos1[0]][pos1[1]][2] == 6: # Pawn promotion
<br>&emsp;&emsp;&emsp;if (pos2[1] == 1 and self.turn_color == 1) or (pos2[1] == 8 and self.turn_color == 2): #Pawn color and position??
<br>&emsp;&emsp;&emsp;&emsp;temp = self.promotion()
<br>&emsp;&emsp;&emsp;&emsp;temp1 = self.board[pos1[0]][pos1[1]][3]
<br>&emsp;&emsp;&emsp;&emsp;self.board[pos1[0]][pos1[1]] = [self.simbols[temp][self.turn_color - 1], self.turn_color, temp + 1, temp1, []]
<br>&emsp;&emsp;&emsp;
<br>&emsp;&emsp;
<br>&emsp;&emsp;if self.board[pos2[0]][pos2[1]][0] in self.squares:
<br>&emsp;&emsp;&emsp;self.board[pos2[0]][pos2[1]] = self.board[pos1[0]][pos1[1]]
<br>
<br>&emsp;&emsp;else:
<br>&emsp;&emsp;&emsp;self.death_pieces[self.turn_color - 1].append(self.board[pos2[0]][pos2[1]][0])
<br>&emsp;&emsp;&emsp;self.board[pos2[0]][pos2[1]] = self.board[pos1[0]][pos1[1]]
<br>
<br>&emsp;&emsp;self.board[pos1[0]][pos1[1]] = [self.squares[0] if (pos1[0] % 2 != 0 and pos1[1] % 2 != 0) or (pos1[0] % 2 == 0 and pos1[1] % 2 == 0) else self.squares[1], 0]
<br>
<br>
<br>############################################
<br>############## curser setting ##############
<br>&emsp;def clean_mark(self):
<br>&emsp;&emsp;self.sub_board[self.main_cursor_point[0]][self.main_cursor_point[1]] = '  '
<br>&emsp;&emsp;for i in range(len(self.sub_cursor_point)):
<br>&emsp;&emsp;&emsp;self.sub_board[self.sub_cursor_point[i][0]][self.sub_cursor_point[i][1]] = '  '
<br>&emsp;&emsp;self.main_cursor_point = []
<br>&emsp;&emsp;self.sub_cursor_point = []
<br>&emsp;&emsp;
<br>&emsp;def set_curser(self, pos):
<br>&emsp;&emsp;self.sub_board[pos[0]][pos[1]] = self.cursor[0]
<br>&emsp;&emsp;self.main_cursor_point = pos
<br>&emsp;&emsp;for i in range(len(self.board[pos[0]][pos[1]][4])):
<br>&emsp;&emsp;&emsp;self.sub_cursor_point.append(self.board[pos[0]][pos[1]][4][i])
<br>&emsp;&emsp;&emsp;self.sub_board[self.sub_cursor_point[i][0]][self.sub_cursor_point[i][1]] = self.cursor[1]
<br>&emsp;&emsp;&emsp;
<br>g = game()
<br>
<br>chess = g.running()
<br>print("{} player Win!".format(chess[0]))
<br>print(chess[1])
<br>print(g.king_position)
<br>a = input()
<br>>>>
3번에 걸친 정리를 했음에도 단순한 기능에 비해 300줄이라는 양이 나온다. 처음에 막무가내로 제작한 뒤에 이런 저런 기능을 덧붙이다가 코드가 더러워져서 처음부터 다시 짜게 되었다. 
<br>참 재미있고 인상깊은 버그가 많았는데 캐슬링을 하면 아군 룩이 킹을 잡아먹어 게임이 상대 승리로 끝나거나 폰이 승급하니 킹이 되어 게임에 킹이 셋 있다거나 하는 버그가 많았다.
<br>체스의 특수룰인 캐슬링과 프로모션을 구현하였으며 앙파상은 구현하지 못했다. 캐슬링은 정말 치가 떨리도록 많이 고생을 했지만 결국 완성을 하였다.
<br>추후에 그래픽 요소와 체크, 체크메이트까지 구현할 예정이다.